//  FuzzyAntecedent class, part of the SPARE library.
//  Copyright (C) 2011 Guido Del Vescovo
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

/** @brief File FuzzyAntecedent.hpp, containing the FuzzyAntecedent template class.
 *
 * The file contains the FuzzyAntecedent template class, implementing a fuzzification system
 * based on scalar membership functions.
 *
 * @file FuzzyAntecedent.hpp
 * @author Guido Del Vescovo
 */

#ifndef _FuzzyAntecedent_h_
#define _FuzzyAntecedent_h_

// STD INCLUDES
#include <iterator>
#include <utility>
#include <vector>

// BOOST INCLUDES
#include <boost/serialization/access.hpp>
#include <boost/serialization/nvp.hpp>
#include <boost/serialization/vector.hpp>

// SPARE INCLUDES
#include <spare/SpareExceptions.hpp>
#include <spare/SpareTypes.hpp>

namespace spare {  // Inclusion in namespace spare.

/** @brief Fuzzification system based on scalar membership functions.
 *
 * The %FuzzyAntecedent class models the @a MultiEvaluator concept. It can be employed as the
 * first stage of a fuzzy model. The fuzzification system is constitued of \f$M\f$ nodes,
 * representing as many input variables. For each of the \f$M\f$ nodes, \f$m_i\f$ terms, are
 * defined, with \f$i=0,1,...,M-1\f$. Each term represents the possible antecedent of a rule.
 * The input is denoted as the \f$M\times1\f$ vector \f$\mathbf{x}\f$, containing the input
 * variables. The output is denoted as the \f$N\times1\f$ vector \f$\boldsymbol{\mu}\f$,
 * where:
 *
 * \f$
 * N=\sum_{i=0}^{M-1} m_i
 * \f$
 *
 * The output vector components are first ordered by node, then by term. More precisely,
 * first we have the outputs generated by the first node, from the first to the last term,
 * then the outputs generated by the second node, and so on. In order to avoid storage
 * redundancies, the membership function objects are stored in an array, then only referenced
 * by the data structure holding nodes and terms. In that way, the same membership function
 * can be employed in different terms and nodes without replication of the object in memory.
 * The setup of the class happens in two steps: first the structural setup has to be defined,
 * then the single membership functions can be edited. The structural setup involves the
 * definition of the number of membership functions in use, the number of nodes and number of
 * terms for each node. When the structure is defined, the membership function objects are
 * allocated, and they can be edited thanks to the suited access property.
 */
template <typename Evaluator>
class FuzzyAntecedent
{
public:

// LIFECYCLE

   /** Default constructor.
    */
   FuzzyAntecedent()
      : mOutputSize(0)
                                                   { }

// OPERATIONS

   /** Membership values evaluation.
    *
    * @param[in] rInput Container holding the \f$\mathbf{x}\f$ vector.
    * @param[out] rOutput Container holding the \f$\boldsymbol{\mu}\f$ vector.
    */
   template <typename SequenceContainer1, typename SequenceContainer2>
   void                 Eval(
                           const SequenceContainer1& rInput,
                           SequenceContainer2&       rOutput) const;

   /** Membership values evaluation.
    *
    * @param[in] aInput Iterator pair delimiting the \f$\mathbf{x}\f$ vector.
    * @param[out] aOutput Iterator pair delimiting the \f$\boldsymbol{\mu}\f$ vector.
    */
   template <typename ForwardIterator1, typename ForwardIterator2>
   void                 Eval(
                           std::pair<ForwardIterator1, ForwardIterator1> aInput,
                           std::pair<ForwardIterator2, ForwardIterator2> aOutput) const;

// ACCESS

   /** Read/write access to membership function.
    *
    * @param[in] aIndex Index of the membership function (index base 0).
    * @return A reference to the membership function.
    */
   Evaluator&           Membership(NaturalType aIndex)
                           {
                              #if SPARE_DEBUG
                              if (aIndex >= mMembs.size())
                              {
                                 throw SpareLogicError("FuzzyAntecedent, 0, "
                                                       "Index out of range.");
                              }
                              #endif

                              return mMembs[aIndex];
                           }

   /** Read only access to membership function.
    *
    * @param[in] aIndex Index of the membership function (index base 0).
    * @return A const reference to the membership function.
    */
   const Evaluator&     Membership(NaturalType aIndex) const
                           {
                              #if SPARE_DEBUG
                              if (aIndex >= mMembs.size())
                              {
                                 throw SpareLogicError("FuzzyAntecedent, 1, "
                                                       "Index out of range.");
                              }
                              #endif

                              return mMembs[aIndex];
                           }

// SETUP

   /** Structural setup.
    *
    * The structural setup is specified by a sequence of integers. The format is the
    * following: first the number of defined membership functions, then the number of nodes,
    * then, for each node a subsequence of values with the following format: first the number
    * of terms, then, for each term, the index of the membership to use for it (index base
    * 0). Example:
    *
    * 5 2 3 0 1 2 2 3 4
    *
    * In the example we have 5 membership functions, 2 nodes. The first node is made of 3
    * terms, associated with the membership functions 0, 1 and 2. The second node is made of
    * 2 terms, associated with the membership functions 3 and 4.
    *
    * @param[in] rStructure Container holding the structure sequence.
    */
   template <typename SequenceContainer>
   void                 StructureSetup(const SequenceContainer& rStructure)
                           {
                              StructureSetup(std::make_pair(
                                                        rStructure.begin(),
                                                        rStructure.end()));
                           }

   /** Structural setup.
    *
    * See the overloaded version for more explanations.
    *
    * @param[in] aStructure Iterator pair delimiting the structure sequence.
    */
   template <typename ForwardIterator>
   void                 StructureSetup(
                                    std::pair<ForwardIterator, ForwardIterator> aStructure);

private:

   // Tipo vettore di funzioni membership.
   typedef std::vector<Evaluator>
                        MembVector;

   // Tipo indice identificativo di una funzione membership.
   typedef typename MembVector::size_type
                        MembVectorSizeType;

   // Tipo vettore di termini (membership associate ad un input).
   typedef std::vector<MembVectorSizeType>
                        TermVector;

   // Tipo vettore di nodi.
   typedef std::vector<TermVector>
                        NodeVector;

   // Size type vettore nodi.
   typedef typename NodeVector::size_type
                        NodeVectorSizeType;

   // Funzioni membership.
   MembVector           mMembs;

   // Nodi.
   NodeVector           mNodes;

   // Output size.
   NaturalType          mOutputSize;

   // Funzione reset.
   void                 ClearAll();

   // BOOST SERIALIZATION
   friend class boost::serialization::access;

   template<class Archive>
   void serialize(Archive & ar, const unsigned int version)
   {
      ar & BOOST_SERIALIZATION_NVP(mMembs);
      ar & BOOST_SERIALIZATION_NVP(mNodes);
      ar & BOOST_SERIALIZATION_NVP(mOutputSize);
   } // BOOST SERIALIZATION

}; // class FuzzyAntecedent

/******************************* TEMPLATE IMPLEMENTATION **********************************/

////////////////////////////////////// PUBLIC //////////////////////////////////////////////

//==================================== OPERATIONS ==========================================

template <typename Evaluator>
template <typename SequenceContainer1, typename SequenceContainer2>
void
FuzzyAntecedent<Evaluator>::Eval(
                               const SequenceContainer1& rInput,
                               SequenceContainer2&       rOutput) const
{
   #if SPARE_DEBUG
   if (rInput.size() != mNodes.size())
   {
      throw SpareLogicError("FuzzyAntecedent, 2, Input of invalid size.");
   }

   if (rOutput.size() != mOutputSize)
   {
      throw SpareLogicError("FuzzyAntecedent, 3, Output of invalid size.");
   }
   #endif

   // Iteratori.
   typename TermVector::const_iterator Mit;
   typename NodeVector::const_iterator Nit;

   // Iteratore a primo container.
   typename SequenceContainer1::const_iterator
                        Sit1= rInput.begin();

   // Iteratore a secondo container.
   typename SequenceContainer2::iterator
                        Sit2= rOutput.begin();

   // Calcolo membership.
   Nit= mNodes.begin();
   while (mNodes.end() != Nit)
   {
      Mit= Nit->begin();
      while (Nit->end() != Mit)
      {
         (*Sit2++)= mMembs[*Mit++].Eval(*Sit1);
      }
      ++Nit;
      ++Sit1;
   }
}

template <typename Evaluator>
template <typename ForwardIterator1, typename ForwardIterator2>
void
FuzzyAntecedent<Evaluator>::Eval(
                               std::pair<ForwardIterator1, ForwardIterator1> aInput,
                               std::pair<ForwardIterator2, ForwardIterator2> aOutput) const
{
   #if SPARE_DEBUG
   if (std::distance(aInput.first, aInput.second) != mNodes.size())
   {
      throw SpareLogicError("FuzzyAntecedent, 4, Input of invalid size.");
   }

   if (std::distance(aOutput.first, aOutput.second) != mOutputSize)
   {
      throw SpareLogicError("FuzzyAntecedent, 5, Output of invalid size.");
   }
   #endif

   // Iteratori.
   typename TermVector::const_iterator Mit;
   typename NodeVector::const_iterator Nit;

   // Calcolo membership.
   Nit= mNodes.begin();
   while (mNodes.end() != Nit)
   {
      Mit= Nit->begin();
      while (Nit->end() != Mit)
      {
         (*aOutput.first++)= mMembs[*Mit++].Eval(*aInput.first);
      }
      ++Nit;
      ++aInput.first;
   }
}

//==================================== SETUP ===============================================

template <typename Evaluator>
template <typename ForwardIterator>
void
FuzzyAntecedent<Evaluator>::StructureSetup(
                                      std::pair<ForwardIterator, ForwardIterator> aStructure)
{
   // Typedef locale.
   typedef typename std::iterator_traits<ForwardIterator>::difference_type
                        ForwardIteratorDiffType;

   // Reset.
   ClearAll();

   // Dimensione sequenza passata.
   ForwardIteratorDiffType Sz= std::distance(aStructure.first, aStructure.second);

   // Iteratori.
   typename TermVector::iterator Mit;
   typename NodeVector::iterator Nit;

   // Variabile ausiliaria.
   NaturalType                   Aux= 0;

   // Controllo dimensione minima sequenza struttura.
   if (Sz < 4)
   {
      throw SpareLogicError("FuzzyAntecedent, 6, Invalid structure sequence.");
   }

   // Controllo numero membership.
   if ((*aStructure.first < 1) || (*aStructure.first > mMembs.max_size()))
   {
      throw SpareLogicError("FuzzyAntecedent, 7, Invalid structure sequence.");
   }

   // Dimensiono vettore membership e avanzo su sequenza struttura.
   mMembs.resize(*aStructure.first++);
   --Sz;

   // Controllo numero nodi.
   if ((*aStructure.first < 1) || (*aStructure.first > mNodes.max_size()))
   {
      ClearAll();
      throw SpareLogicError("FuzzyAntecedent, 8, Invalid structure sequence.");
   }

   // Dimensiono vettore nodi e avanzo su sequenza struttura.
   mNodes.resize(*aStructure.first++);
   --Sz;

   // Ciclo setup nodi.
   Nit= mNodes.begin();
   while (mNodes.end() != Nit)
   {
      // Controllo numero termini.
      if ((*aStructure.first < 1) || (*aStructure.first > Nit->max_size()))
      {
         ClearAll();
         throw SpareLogicError("FuzzyAntecedent, 9, Invalid structure sequence.");
      }

      // Aggiorno OutputSize con check overflow (FIXME il check non rileva tutti i casi).
      Aux= mOutputSize;
      mOutputSize+= (*aStructure.first);
      if (mOutputSize <= Aux)
      {
         ClearAll();
         throw SpareLogicError("FuzzyAntecedent, 10, Output size overflow.");
      }

      // Dimensiono vettore termini e avanzo su sequenza struttura.
      Nit->resize(*aStructure.first++);
      --Sz;

      // Controllo dimensione (FIXME: attenzione al casting).
      if (Sz < static_cast<ForwardIteratorDiffType>(Nit->size()))
      {
         ClearAll();
         throw SpareLogicError("FuzzyAntecedent, 11, Invalid structure sequence.");
      }

      // Ciclo setup termini.
      Mit= Nit->begin();
      while (Nit->end() != Mit)
      {
         // Controllo termine.
         if ((*aStructure.first < 0) || (*aStructure.first >= mMembs.size()))
         {
            ClearAll();
            throw SpareLogicError("FuzzyAntecedent, 12, Invalid structure sequence.");
         }

         // Imposto termine e avanzo su sequenza struttura.
         (*Mit++)= *aStructure.first++;
         --Sz;
      }
      ++Nit;
   }

   if (Sz > 0)
   {
      ClearAll();
      throw SpareLogicError("FuzzyAntecedent, 13, Invalid structure sequence.");
   }
}

////////////////////////////////////// PRIVATE /////////////////////////////////////////////

template <typename Evaluator>
void
FuzzyAntecedent<Evaluator>::ClearAll()
{
   mMembs.clear();
   mNodes.clear();
   mOutputSize= 0;
}

}  // namespace spare

#endif  // _FuzzyAntecedent_h_
